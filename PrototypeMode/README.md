### 简介
原型模式(Prototype):原型模式属于对象的创建模式。通过给出一个原型对象来指明所有创建的对象的类型，然后用这个原型对象提供的复制办法创建出更多同类型的对象。  

原型模式要求对象实现一个可以克隆自身的接口(类型)。这样一来，通过原型实例创建新的对象，就不需要关心这个实例本身的类型，
只需要实现克隆自身的方法，也而无需再去通过new来创建。   

### 原型模式的表现形式
1. 简单形式
2. 登记形式

### 简单形式
![](https://ws1.sinaimg.cn/large/006mOQRagy1g5wqa9ii2zj30kr06n0sn.jpg)  
相关角色：  
客户(Client)角色：客户类提出创建对象的请求；   
抽象原型(Prototype)角色：这是一个抽象角色，通常由一个Java接口或者Java抽象类实现。此角色定义了的具体原型类所需的实现的方法。   
具体原型(Concrete Prototype)角色：此角色需要实现抽象原型角色要求的克隆相关的接口。   

### 登记形式
![](https://ws1.sinaimg.cn/large/006mOQRagy1g5wqi56dx7j30os08y0sv.jpg)  
相关角色  

客户(Client)角色：客户类提出创建对象的请求；  
抽象原型(Prototype)角色：这是一个抽象角色，通常由一个Java接口或者Java抽象类实现。此角色定义了的具体原型类所需的实现的方法。  
具体原型(Concrete Prototype)角色：此角色需要实现抽象原型角色要求的克隆相关的接口。  
原型管理器(Prototype Manager)角色：提供各种原型对象的创建和管理。  

两者的比较  
简单形式和登记形式的原型模式各有其长处和短处。  

1. 如果要创建的原型对象数据较少而且比较固定的话，可以采用第一种形式。在这种情况下，原型对象的引用可以由客户端自己保存。
2. 如果要创建的原型对象数据不固定的话，可以采用第二种形式。在这种情况下，客户端不保存对原型对象的引用，这个任务被交给原型管理器角色。在克隆一个对象之前，客户端可以查看管理员对象是否已经有一个满足要求的原型对象。如果有，可以从原型管理器角色中取得这个对象引用；如果没有，客户端就需要自行复制此原型对象。

### 总结
#### 原型模式的优点
原型模式允许在运行时**动态**改变具体的实现类型。原型模式可以在运行期间，有客户来注册符合原型接口的实现类型，也可以动态的改变具体的实现类型，看起来接口没有任何变化，但是其实运行的已经是另外一个类实体了。**因为克隆一个原型对象就类似于实例化一个类。**
#### 原型模式的缺点
原型模式最主要的缺点是每一个类都必须要配备一个克隆方法。配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类来说并不是很难，但是对于已有的类来说并不容易。


参考链接：  
https://juejin.im/post/5b48bec15188251b3d79bf9c  
